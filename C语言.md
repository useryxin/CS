#### C格式说明符

以下是C语言中的格式说明符的详细说明，包括一些不太常见的格式说明符：

1. `%d`：用于整数（十进制）的格式说明符。可以用于`int`类型。
   - 示例：`printf("%d", 42);`，将输出整数 `42`。
2. `%ld`：用于长整数（长整型，十进制）的格式说明符。通常用于`long`类型。
   - 示例：`printf("%ld", 10000000000L);`
3. `%lld`：用于长长整数（长长整型，十进制）的格式说明符。通常用于`long long`类型。
   - 示例：`printf("%lld", 100000000000000LL);`
4. `%f`：用于浮点数的格式说明符。通常用于`float`和`double`类型。
   - 示例：`printf("%f", 3.14159);`
5. `%lf`：用于双精度浮点数（双精度浮点型）的格式说明符。通常用于`double`类型。
   - 示例：`printf("%lf", 3.14159265359);`
6. `%c`：用于字符的格式说明符。通常用于`char`类型。
   - 示例：`printf("%c", 'A');`
7. `%s`：用于字符串的格式说明符。通常用于字符数组（字符串）。
   - 示例：`printf("%s", "Hello, World!");`
8. `%x`：用于整数的十六进制格式。通常用于`int`类型。
   - 示例：`printf("%x", 255);`，将输出十六进制值 `ff`。
9. `%X`：与`%x`类似，但输出大写字母的十六进制值。
10. `%o`：用于整数的八进制格式。通常用于`int`类型。
    - 示例：`printf("%o", 64);`，将输出八进制值 `100`。
11. `%u`：用于无符号整数的格式说明符。通常用于`unsigned int`类型。
    - 示例：`printf("%u", 12345);`
12. `%p`：用于指针的格式说明符。通常用于指向任何数据类型的指针。
    - 示例：`printf("%p", &variable);`，将输出指向变量 `variable` 的内存地址。
13. `%e`：用于科学计数法的浮点数表示。
    - 示例：`printf("%e", 1.23e-4);`，将输出 `1.230000e-04`。
14. `%E`：与`%e`类似，但输出大写字母的指数。
15. `%g`：用于自动选择 `%f` 或 `%e` 来表示浮点数，以较短的形式表示。
    - 示例：`printf("%g", 0.000012345);`，可能输出 `1.2345e-05` 或 `0.000012345`，取决于精度。
16. `%G`：与`%g`类似，但输出大写字母的指数。
17. `%%`：用于打印百分号字符。
    - 示例：`printf("The discount is 20%%.");`，将输出 "The discount is 20%."

这些是C语言中的常见格式说明符，可以根据需要将它们与修饰符（如宽度、精度等）结合使用，以更精细地控制格式化的输出或输入。不同的数据类型需要相应的格式说明符，确保在使用 `scanf` 时提供正确的地址来存储输入的数据。

`%#x` 是C语言中的格式说明符，通常用于在输出时以十六进制格式打印整数。这个格式说明符的作用是在输出的十六进制数字前添加前缀 `0x`，以明确表明数字是十六进制的。以下是一个示例：

```c
int num = 255;
printf("%#x", num);
```

在这个示例中，`%#x` 将以十六进制格式打印整数 `num`，输出将是 `0xff`。前缀 `0x` 表示这是一个十六进制值。

`%#x` 格式说明符通常用于增加可读性，特别是在调试和输出十六进制数据时非常有用。如果省略 `#` 符号，输出将不包含前缀 `0x`。



#### 算术移位

当涉及到位移操作时，了解算术移位和逻辑移位的细节非常重要，尤其是在处理有符号整数时。下面将更详细地解释这两种操作的工作方式和使用场景。

**算术左移 (Arithmetic Left Shift)**：

- 算术左移将二进制数向左移动指定的位数。移位后，最左侧的位将被舍弃，右侧将填充零。

- 算术左移等效于将整数乘以2的幂。每次左移一位，相当于乘以2。
  $$ {1}
  公式为：\\
  (value<<n)时value*2^n\\
  (value>>n)时value/2^n\\
  $$

**算术右移 (Arithmetic Right Shift)**：

- 算术右移将二进制数向右移动指定的位数。移位后，最右侧的位将被舍弃，而左侧将填充与原最高位相同的位（即符号位）。如果原数是正数，那么填充零；如果原数是负数，那么填充一位1。
- 算术右移通常用于保持整数的符号。它允许负数继续保持负数，而正数保持正数。

**逻辑左移 (Logical Left Shift)**：
- 逻辑左移与算术左移类似，将二进制数向左移动指定的位数。移位后，最左侧的位被丢弃，右侧填充零。
- 逻辑左移通常用于无符号整数，因为它不关心符号。

**逻辑右移 (Logical Right Shift)**：
- 逻辑右移将二进制数向右移动指定的位数。移位后，最右侧的位被丢弃，左侧填充零。无论原数是正数还是负数，都填充零。
- 逻辑右移通常用于无符号整数。

$$
在算术移位中移位的长短，会导致最高位发生变化。\\然而在逻辑移位中，最高位始终不会发生变化，所以适用无符号整数。
$$

需要特别注意的是，不同的编程语言和硬件平台可能对算术移位和逻辑移位的行为有所不同，因此在使用时要谨慎，确保了解特定环境下的移位行为。通常，算术移位在处理有符号整数时更为常见，而逻辑移位在处理无符号整数和位操作时更常见。







#### typedef关键字的使用

`typedef` 是C和C++等编程语言中的一个关键字，用于创建新的数据类型别名，使代码更易读和理解。`typedef` 允许程序员定义自己的数据类型名称，以简化代码和提高可维护性。以下是`typedef`关键字的使用示例：

###### **基本数据类型的别名**：

```c
typedef int MyInt; // 创建一个整数的别名
MyInt x = 42;
```
这里，`MyInt` 成为 `int` 的别名，您可以使用 `MyInt` 来声明变量，这使得代码更具可读性。

###### **结构体的别名**：

```c
typedef struct {
    int x;
    int y;
} Point; // 创建一个结构体的别名
Point p1;
p1.x = 5;
p1.y = 10;
```
这里，`Point` 成为了一个结构体的别名，使得声明和使用结构体更加简洁。

###### **函数指针的别名**：

```c
typedef int (*MathFunction)(int, int); // 创建一个函数指针类型的别名
int add(int a, int b) {
    return a + b;
}
MathFunction operation = add;
int result = operation(3, 4);
```
在这个示例中，`MathFunction` 成为一个函数指针类型的别名，它可以指向具有相同签名的函数。

###### 枚举的别名：

```c
typedef enum {
    RED,
    GREEN,
    BLUE
} Color; // 创建一个枚举类型的别名
Color favoriteColor = GREEN;
```
这里，`Color` 成为一个枚举类型的别名，使得使用枚举值更加清晰。

###### **指针类型的别名**：

```
cCopy codetypedef int* IntPtr; // 创建一个整数指针的别名
int num = 42;
IntPtr ptr = &num;
```

`IntPtr` 成为指向整数的指针的别名，可以用于声明指向整数的指针变量

`typedef` 关键字可以显著提高代码的可读性，特别是在处理复杂的数据类型或在多个地方重复使用相同类型时。它还可以用于封装库中的数据类型，使其更具可移植性，因为库开发者可以更轻松地更改实际数据类型而不会影响用户的代码。





#### 指针

C语言中的指针是一种非常重要的数据类型，它用于存储内存地址并提供了对内存中数据的直接访问。指针是C语言的关键特性之一，能够有效地进行内存管理和数据操作。下面是关于C语言指针的详细介绍：

###### 指针的声明和定义：

- 使用`*`运算符来声明指针变量，例如：`int *ptr;` 表示声明了一个指向整数的指针。
- 指针变量需要初始化为合法的内存地址，通常可以使用`&`运算符取得一个变量的地址，并将其赋值给指针变量。

指针的解引用**：
- 使用`*`运算符对指针进行解引用，以获取指针所指向的内存中的值。例如：`int x = *ptr;` 会将指针`ptr`所指向的整数值赋给变量`x`。

###### 指针的运算：

- 指针可以进行算术运算，如加法和减法。这允许你在内存中导航，访问数组元素等。例如：`ptr++` 会将指针向前移动到下一个元素。
- 指针的加法和减法操作都是基于数据类型的大小。例如，如果`ptr`是一个`int`指针，则`ptr++`会将指针移动到下一个整数的位置。

###### 指针与数组：

- 数组名本质上是一个指向数组第一个元素的指针。例如：`int arr[5]; int *ptr = arr;`，`ptr`指向数组`arr`的第一个元素。
- 可以使用指针来遍历数组元素，而不必使用数组下标。例如：`for (int i = 0; i < 5; i++) { printf("%d\n", *(ptr + i)); }`。

###### **指针与函数**：

- 指针可以用于传递函数参数，允许函数修改传递给它的变量的值。这称为通过引用传递。例如：`void modifyValue(int *x) { *x = 10; }`。

###### **指针与动态内存分配**：

- 使用`malloc`、`calloc` 或 `realloc` 函数来动态分配内存，并返回一个指向分配内存的指针。必须记得释放这些内存，以避免内存泄漏。例如：`int *arr = (int *)malloc(sizeof(int) * 10);`。

###### **指针的 NULL 值**：

- 可以使用 `NULL` 宏来表示指针变量的空值。这对于检查指针是否有效非常有用。例如：`int *ptr = NULL;`。

###### 指针的安全性和悬空指针：

- 未初始化的指针或已释放的指针可能会成为悬空指针，访问悬空指针会导致不可预测的行为，甚至导致程序崩溃。因此，指针的安全使用非常重要。
- 

总之，C语言指针是一个非常强大的工具，但也需要小心使用，以确保内存安全性和程序稳定性。正确使用指针可以提高代码的性能和灵活性，但不正确的使用可能会导致难以调试的错误。因此，在使用指针时要格外小心。

```c
#include <stdio.h>
int main() {
    int const a=15;
    int const *const pci=a;//定义指针常量    
    int a=&pci;//期望使用二级指针变量改变pci里面的常量    
    a=100;    
    printf("%d\n",pci);    
    printf("%p",&pci);    
    return 0;//未成功
    个人观点//常量和指针的关系：变量对象于变量指针而言，只会改变数值大小，并不会控制指针指向常量对象于常量指针而言，双方基本没有操作空间
```

```c
#include <stdio.h>
#include <stdlib.h>

/*
 * 函数中简介修改指针值
 */
void modify_pointer(int **p)
{
    // 间接修改指针的值
    *p = 456789;
}

int main()
{
    // 定义普通变量
    int a = 0;

    // 声明指针变量 , 并为其设置 NULL 初始值
    // NULL 就是22222空
    int *p = NULL;

    // 声明二级指针变量 , 并为其设置 NULL 初始值
    int **p2 = NULL;

    // 将变量地址赋值给一级指针
    p = &a;

    // 打印一级指针地址
    printf("%d\n", p);

    // 将一级指针的地址赋值给二级指针
    p2 = &p;

    // 间接修改指针的值
    *p2 = 12345678;

    // 打印一级指针地址
    printf("%d\n", p);

    // 在函数中 , 简介修改指针的值
    modify_pointer(p2);

    // 打印一级指针地址
    printf("%d\n", p);

    // 命令行不要退出
    system("pause");
    return 0;
}
```

```c
#include"stdio.h"
int main(){
    char a[]="null";
    scanf("%s",&a);
    int *pc=&a;
    printf("%s\n",pc);
    int **pa=pc;//二级指针
    printf("%s\n",pa);
    return 0;
}
```



```c
//字符串动画的实现
#include <windows.h>
#include<stdio.h>
#include<time.h>
#include<string.h>

void s(void) {
sout:;
    char arr1[] = "I LOVE YOU";
    char arr2[] = "          ";

    int left = 0;

    int right = sizeof(arr1) - 2;
    while (left <= right)
    {
        arr2[left] = arr1[left];
        arr2[right] = arr1[right];
        printf("%s\n", arr2);
        Sleep(1000);
        system("cls");//清空屏幕
        left++;
        right--;
    }
    goto sout;
    return;
}


void f(void) {
A:;
    char arr1[] = "I_LOVE_YOU";
    char arr2[] = "          ";
    int mid = sizeof(arr1)/2;
    int left = mid-1, right = mid;


    while (left <= right)
    {
        arr2[left] = arr1[left];
        arr2[right] = arr1[right];
        printf("%s\n", arr2);
        Sleep(1000);
        system("cls");//清空屏幕
        left--;
        right++;
    }
    goto A;
    return;
}

void main(void) {
}
```




```c
#include"stdio.h"
    //a==5 b==3 3c==1 总共100 则三者个为几何 典型的穷举法：当条件较少并满足时，把所有满足条件调用，使计算机自己计算
int main(){
    int a,b,c;
    for(a=0;a<=100;a++)
    {
        for(b=0;b<=100;b++)
        {
            for(c=0;c<=100;c++)
            {
                if(5*a+3*b+c/3==100&&a+b+c==100&&c%3==0)
                    printf("a=%d,b=%d,c=%d\n",a,b,c);
            }
        }
    }
    return 0;
}
```

<img src="D:\Note\MD笔记\Image\image-20230827110655671.png" alt="image-20230827111017889" style="zoom: 33%;" />



```c
char* strcpy(char* dst, const char* src)
{
    if ((dst == NULL) || (src == NULL))
        return NULL;

    char* ret = dst; 

    while ((*dst++ = *src++) != '\0'); 

    return ret;
}
```



```c
int strlen(char *Str) {
	int index = 0;
	while (*Str++ != '\0') {
		index++;
	}
	return index;
}
```

```c
#include <stdio.h>

int *accay(int* u) {
    u += 9;
    return u;
}

const signed int a = 100;

int main() {
    int key = accay(a);
    printf("%d\n", key);
    printf("%d", a);
    return 0;
}
```

二维数组

```c
#include"stdio.h"

const int Xlenght=3,Ylenght=3,Zlenght=4;
int mslarray[Xlenght][Ylenght][Zlenght]={
        {
            {1,2,3,4},
            {2,3,4,5},
            {4,9,2,2}
        },
        {
            {1,3,6,3},
            {5,3,5,3},
            {4,3,3,2}
        },
        {
            {4,5,2,2},
            {5,6,2,2},
            {9,6,2,7},
        },
 };

int i=0,j=0;
int *pointer1,*pointer2;

int main(){
    pointer1=&mslarray[0][0][0];
    while(i<Xlenght*Ylenght*Zlenght){
        printf("%d ",*pointer1+i);
        i++;
    }
    return 0;

```

#### C各区的定义

在C语言中，内存分为不同的区域，通常包括以下几个主要的区域，每个区域有其特定的用途和生命周期：

1. **栈（Stack）**：
   - 栈是用于存储函数调用和局部变量的内存区域。
   - 每次函数被调用时，该函数的局部变量都会被分配到栈上。
   - 栈的特点是后进先出（LIFO），即最后进栈的变量最先出栈。
   - 局部变量在函数退出时自动销毁，不需要手动释放。
   - 栈的内存分配和释放是自动管理的，通常由编译器和操作系统负责。

2. **堆（Heap）**：
   - 堆是用于动态分配内存的内存区域，通常用于存储动态数据结构，如链表、树和对象。
   - 堆内存需要手动分配和释放，程序员负责管理其生命周期。
   - 堆内存通常比栈大，不受固定大小的限制。
   - 堆的分配和释放由程序员通过函数如`malloc`、`calloc`、`realloc`和`free`来控制。

3. **全局/静态区（Global/Static Area）**：
   - 全局区用于存储全局变量和静态变量。
   - 全局变量在程序启动时创建，并在程序退出时销毁。
   - 静态变量在其作用域内保留其值，并且不会被销毁。
   - 全局变量和静态变量在整个程序的生命周期内存在。

4. **文字常量区（Text/Code Segment）**：
   - 文字常量区存储程序的代码和常量数据。
   - 通常，程序代码和常量字符串等在这个区域中，不可修改。
   - 文字常量区的数据在程序运行期间不可更改。

5. **常量区（Constant Area）**：
   - 常量区存储不可更改的常量数据，如字符串常量。
   - 这些数据在程序运行期间不可修改。

6. **堆栈区（BSS，Block Started by Symbol）**：
   - BSS区用于存储未初始化的全局变量和静态变量。
   - 这些变量在程序启动时被初始化为零或空，不需要显式初始化。
   
7. **寄存器（Register）**：
   - 寄存器是CPU内部的内存区域，用于存储临时数据和快速访问变量。
   - 程序员通常无法直接控制寄存器，编译器会自动优化变量的分配和访问。

不同的编译器、操作系统和平台可能会有不同的内存管理机制和命名约定，但这些是C语言通用的内存区域。了解这些区域的存在和基本特征对于正确管理内存和避免内存泄漏和错误非常重要。在C语言中，程序员通常需要手动管理堆内存，而栈和全局变量的管理由编译器和运行时系统自动处理。



###### 为什么将堆（Heap）和栈（Stack）分开：

1. **内存管理灵活性**：
   - 堆和栈的分离允许程序员根据需要灵活地分配和释放内存。栈上的内存分配和释放是自动的，而堆上的内存分配和释放由程序员手动控制。
   - 堆内存的手动管理使程序能够在运行时动态地分配和释放内存，这对于处理不定数量和大小的数据结构非常有用。

2. **局部变量的生命周期管理**：
   - 栈上的内存用于存储局部变量，这些变量的生命周期与函数调用的开始和结束直接相关。当函数退出时，栈上的局部变量自动被销毁，无需额外的操作。
   - 这种自动管理有助于避免内存泄漏和资源泄漏。

3. **栈的高效性**：
   - 栈的内存分配和释放非常高效，因为它是一个固定大小的内存区域，仅需要移动栈指针即可分配和释放内存。
   - 栈上的数据结构通常具有更快的访问速度，因为栈上的数据在内存中是紧凑排列的，而且局部性原理使得访问局部变量更加高效。

4. **堆的灵活性和扩展性**：
   - 堆允许动态分配和释放内存，因此可以处理不定数量和大小的数据。这使得堆非常适合存储动态数据结构，如链表、树和动态数组。
   - 堆上的内存可以在程序运行时根据需求进行扩展，而栈的大小通常是固定的。

5. **安全性和稳定性**：
   - 栈的自动管理有助于避免许多内存相关的错误，如空指针引用、内存泄漏和越界访问。局部变量的生命周期受到严格控制，不容易出现问题。
   - 堆上的内存管理需要更多的注意和负担，但也提供了更大的灵活性，因此程序员需要小心确保内存的正确分配和释放。

总之，将堆和栈分开允许程序在内存管理、性能和安全性方面取得平衡。栈用于局部变量的自动管理和高效访问，而堆用于动态分配内存以满足程序的动态需求。这种分离使得C和类似的编程语言能够同时提供高性能、灵活性和可维护性。





`register` 关键字是C语言中的一个关键字，用于向编译器建议将变量存储在寄存器中，以便提高对该变量的访问速度。但需要注意的是，`register` 关键字在现代编译器中的用法已经发生了变化，因此在实际编程中，很少使用 `register` 关键字来指示编译器将变量存储在寄存器中。以下是关于 `register` 关键字的一些条件和注意事项：

1. **建议性关键字**：
   - `register` 关键字是一个建议性关键字，意味着它向编译器提出请求，要求将变量存储在寄存器中，以提高访问速度。
   - 编译器不一定会遵循这个请求，因为它可能会根据编译器的优化策略和目标架构来决定是否将变量存储在寄存器中。
2. **限制条件**：
   - `register` 关键字只能用于自动变量（即局部变量），不能用于全局变量或静态变量。
   - 变量必须是可寻址的，也就是说，你不能使用 `register` 来声明指针或数组类型的变量。
3. **不再常用**：
   - 在现代编译器中，`register` 关键字的使用已经不再普遍，因为大多数编译器都能够根据上下文和优化策略自动选择是否将变量存储在寄存器中。
   - 事实上，现代编译器通常会忽略 `register` 关键字，因此在代码中使用它通常没有实际效果。
4. **编译器优化**：
   - 编译器通常会进行优化，自动选择最佳的寄存器分配策略，因此程序员不需要手动指定哪些变量应该存储在寄存器中。

总的来说，`register` 关键字在现代C编程中的用途非常有限，因为编译器通常能够更好地处理寄存器的分配。程序员可以信赖编译器的优化能力，而不需要手动干预变量的寄存器分配。因此，在大多数情况下，不建议使用 `register` 关键字，而应该依赖于编译器的自动优化。



 register关键字使用的条件

- register变量必须是能被CPU所接受的类型。
- 这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。
- 因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址。
- 只有局部自动变量和形式参数可以作为寄存器变量，其它（如全局变量）不行。
- 在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束后释放寄存器。此后，在调用另外一个函数时又可以利用这些寄存器来存放该函数的寄存器变量。
- 局部静态变量不能定义为寄存器变量。不能写成：register static int a, b, c;
- 由于寄存器的数量有限（不同的CPU寄存器数目不一），不能定义任意多个寄存器变量，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略



###### C无内存常量

在C语言中，有一种特殊类型的变量叫做"常量"，它们与普通变量不同，不会分配内存空间来存储值。C语言中有几种不同类型的常量，包括字面常量、符号常量和枚举常量，它们在编程中非常有用。以下是对这些常量的详细介绍：

1. **字面常量（Literal Constants）**：
   
   - 字面常量是编程语言中的固定值，直接写在程序代码中，不会分配内存空间。
   - 例如，整数常量`42`、浮点数常量`3.14`、字符常量`'A'`和字符串常量`"Hello, World!"`都属于字面常量。
   - 字面常量用于提供固定的数据值，而不需要存储在内存中。
   
   ```c
   int x = 42;         // 整数字面常量
   float pi = 3.14;    // 浮点数字面常量
   char letter = 'A';  // 字符字面常量
   char *str = "Hello, World!";  // 字符串字面常量
   ```
   
2. **符号常量（Symbolic Constants）**：
   - 符号常量是使用`#define`指令定义的，它们代表一个固定的值，通常用于增强代码的可读性和可维护性。
   - 符号常量在编译时被替换为其具体的值，不会分配内存空间。
   - 例如，以下代码定义了一个符号常量，用于表示圆周率：

   ```c
   #define PI 3.14
   ```

   - 在代码中使用符号常量时，编译器会将所有出现的 `PI` 替换为 `3.14`。

3. **枚举常量（Enum Constants）**：
   
   - 枚举是一种用户定义的数据类型，它包含一组命名的常量值。这些常量值不会分配内存空间。
   - 例如，以下代码定义了一个枚举类型 `Color`，其中包含三个枚举常量：`RED`、`GREEN` 和 `BLUE`。
   
   ```c
   enum Color {
       RED,
       GREEN,
       BLUE
   };
   ```
   
   - 在代码中使用枚举常量时，它们仅代表其相应的整数值，不会分配额外的内存。

**4.寄存器常量(Register constant)**

- 寄存器常量是一种特殊类型的符号常量，通常用于向编译器建议将某个变量存储在CPU的寄存器中，以提高对该变量的访问速度。

- 以下是使用`register`关键字声明寄存器常量的示例：

- ```c
  register int x;  // 声明一个寄存器变量x
  ```

- `register`关键字用于向编译器提出建议，但不保证变量将存储在寄存器中。

**5.普通定义的常量是有内存的**
	const 是内存分配的!
	关键字const 并不能把变量变成常量!在一个符号前加上const 限定符只是表示这个符号 不能被赋值。也就是它的值对于这个符号来说是只读的，但它并不能防止通过程序的内部(甚至是外部)的方法来修改这个值。

```c
1.static的使用
#include <stdio.h>
void test()
{
    static int a=0;//static可以改变局部变量的生命周期（本质上是改变了变量的贮存类型）
    a++;
    printf("%d\n",a);
}
int main() {
int b=0,c=0;
while(b<360)
{
    test();”
    b++;
}
printf("%d",c);
return 0;
}
```

#### 数组函数的使用

###### 1.数组或字符串的长度:sizeof()、strlen()

​	1、`sizeof()`:返回所占总空间的字节数
​	（1）对于整型字符型数组
​	（2）对于整型或字符型指针
​	2、`strlen()`:返回字符数组或字符串所占的字节数
​	（1）针对字符数组
​	（2）针对字符指针

​	   `sizeof(...)`是运算符，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。

​	    `strlen(...)`是函数，要在运行时才能计算。参数必须是字符型指针`（char）`。当数组名作为参数传入时，实际上数组就退化成指针了。它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符'\0'。返回的长度大小不包括'\0'。

​	     `strlen(char)`函数求的是字符串的实际长度，它求得方法是从开始到遇到第一个'\0',如果你只定义没有给它赋初值，这个结果是不定的，它会从aa首地址一直找下去，直到遇到'\0'停止。

​	     `c/c++ strlen(str)`和`str.length()`和`str.size()`都可以求字符串长度,其中`str.length()`和`str.size()`是用于求`string`类对象的成员函数
​	     `strlen(str)`是用于求字符数组的长度，其参数是char。

​	3、`sizeof()`、`strlen()`两者区别：

​		(1)`sizeof`操作符的结果类型是`size_t`，它在头文件中`typedef`为`unsigned int`类型,该类型保证能容纳实现所建立的最大对象的字节大小。 
​		(2)`sizeof`是运算符，strlen是函数。 
​		(3)`sizeof`可以用类型做参数，strlen只能用char做参数，且必须是以''\0''结尾的。
​		 `sizeof`还可以用函数做参数，比如： 

```c
short f(); 
		printf("%d\n", sizeof(f())); 
		输出的结果是sizeof(short)，即2。
```

​	 (4)数组做`sizeof`的参数不退化，传递给`strlen`就退化为指针了。 
​     (5)大部分编译程序 在编译的时候就把`sizeof`计算过了 是类型或是变量的长度。这就是`sizeof(x)`可以用来定义数组维数的原因 


```c
char str[20]="0123456789"; 
		int a=strlen(str); //a=10; 
		int b=sizeof(str); //而b=20;
```

​	(6)`strlen`的结果要在运行的时候才能计算出来，用来计算字符串的长度，不是类型占内存的大小。 
​	(7`)sizeof`后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为`sizeof`是个操作符不是个函数。 
​	(8)当使用了一个结构类型或变量时， `sizeof` 返回实际的大小， 当使用一静态地空间数组， `sizeof` 返回全部数组的尺寸。 `sizeof` 操作符不能返回被动态分配的数组或外部的数组的尺寸 

###### 2.string中length()和size()

​	c++中的`size()`和`length()`没有区别
​	如：
​	

```c
	string str="0123456789";
		cout <<"str.length()="<<str.length()<<endl;//结果为10
		cout <<"str.size()="<<str.size()<<endl;//结果为10
```



#### main函数的参数

```c
argv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针，argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，*argc** 将被设置为 2

int main(int argc,char *argv[],char *envp[])
```



```c
#include<stdio.h>
#include<unistd.h>
#define REGS_FOREACH(_)  _(X) _(Y)
#define RUN_LOGIC        X1 = !X && Y; \
                         Y1 = !X && !Y;
#define DEFINE(X)        static int X, X##1;
#define UPDATE(X)        X = X##1;
#define PRINT(X)         printf(#X " = %d; ", X);

int main() {
  REGS_FOREACH(DEFINE);
  while (1) { // clock
    RUN_LOGIC;
    REGS_FOREACH(UPDATE);
    putchar('\n'); sleep(1);
  }
}
```

#### 递归

递归是一种在计算机科学中常见的编程和问题解决技巧，它允许函数在执行过程中调用自身。递归函数是一个函数，它通过将问题分解成更小的子问题来解决复杂的问题，每个子问题都与原始问题具有相同的结构。下面是关于递归的详细介绍：

###### 递归的基本原理：

1. **基本情况（Base Case）**：递归函数必须定义一个或多个基本情况，即在这些情况下函数不再调用自身，而是直接返回一个结果。基本情况是递归终止的条件。

2. **递归情况（Recursive Case）**：递归函数在非基本情况下调用自身，通常是将原始问题分解成一个或多个更小的子问题。每个子问题的解决方法通常与原始问题的解决方法相同，只不过问题规模更小。

3. **递归链（Recursion Chain）**：递归链是递归函数调用自身的序列，每次调用都将问题规模减小，最终达到基本情况，然后逐步返回结果。

###### 递归的示例：

递归可以应用于各种问题，以下是一些示例：

- **阶乘计算**：计算一个正整数的阶乘。基本情况是当输入为1时，阶乘为1；递归情况是n的阶乘等于n乘以(n-1)的阶乘。

```c
int factorial(int n) {
    if (n == 1) {
        return 1;  // 基本情况
    } else {
        return n * factorial(n - 1);  // 递归情况
    }
}
```

- **斐波那契数列**：计算斐波那契数列的第n个数。基本情况是n为0或1时，返回n；递归情况是第n个数等于第(n-1)和第(n-2)个数的和。

```c
int fibonacci(int n) {
    if (n == 0 || n == 1) {
        return n;  // 基本情况
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);  // 递归情况
    }
}
```

###### 递归的优点与注意事项：

- **简洁性**：递归可以使代码更简洁和易于理解，尤其是对于解决自相似性问题的情况。

- **问题分解**：递归可以将大问题分解为小问题，每个小问题的解决方法相同，使得问题更容易解决。

- **注意堆栈溢出**：递归可能导致堆栈溢出，因此必须确保递归链的深度不会太大。可以使用尾递归或迭代来减少堆栈的使用。

- **性能开销**：递归函数的性能通常比迭代函数差，因为每个递归调用都会引入额外的函数调用开销和堆栈开销。

- **维护状态**：递归可能需要维护递归状态，例如递归调用的参数和局部变量。这些状态在递归链中传递。

总之，递归是一种强大的编程技巧，它在解决自相似性问题和将问题分解为更小部分时非常有用。理解递归的基本原理以及合理地选择递归或迭代可以帮助你更好地解决各种问题。

###### 递归的详细说明：

​		(1)在求f(n, other variables)的时候，你就默认f(n -1, other variables)已经被求出来了——至于怎么求的，这个是计算机通过回溯求出来的。

PS:这里用到了一种叫做栈(stack)的先进后出的数据结构，所以递归输出的答案一般是自下而上的。

​		(2)递归和二叉树是密切相关的。可以尝试通过二叉树的数据结构来理解递归是如何将一个问题拆分成若干子问题，求解再回溯的。这里可以参考以下快速排序(QuickSort)的过程（快速排序的核心思想是分治，分治即分而治之，通过递归将原问题分解为若干容易求解的子问题，再通过递归将这些子问题联系起来并向二叉树的上层回溯，最终求解出原问题）

###### 递归的条件

​	（1）递归的结束条件（不写会死循环，TLE）
​	（2）递归最后一层和其他有关系的层的关系怎样用非递归函数来表达	
​	比如：斐波纳契亚数列，（1）当n==1和n==2的时候f(n)=1，这就是递归的终止条件。给了终止条件，计算机才能进行求解子问题并回溯，最终求出f(n)

```c
	汉诺塔问题是一个经典的问题。汉诺塔（Hanoi Tower），又称河内塔，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？
	递推式:h(x)=2h(x-1)+1
	h(64)=18446744073709551615
    
#include <stdio.h>
 
int cnt;
 
void move(int id, char from, char to) // 打印移动方式：编号，从哪个盘子移动到哪个盘子
{
    printf ("step %d: move %d from %c->%c\n", ++cnt, id, from, to);
}
 
void hanoi(int n, char x, char y, char z)
{
    if (n == 0)
        return;
    hanoi(n - 1, x, z, y);
    move(n, x, z);
    hanoi(n - 1, y, x, z);
}
```

```c
青蛙跳台阶
#include<stdio.h>
int frog(int n)
{
   if(n == 1)
   {
      return 1;
   }
   if(n == 2)
   {
      return 2;
   }
   return frog(n-1) + frog(n-2);
}
int main()
{
   int n;
   scanf("%d",&n);
   int ways = frog(n);
   printf("%d\n",ways);
   return 0;
}
	
        
#include <stdio.h>
int main() {
    int const *pci=int const a=15;//定义指针变量
    int a=&pci;//期望使用二级指针变量改变pci里面的常量
    a=100;
    printf("%d\n",pci);
    printf("%p",&pci);
    return 0;//未成功
} 
```

```c
//斐波那数列
#include <stdio.h>
int main()
{
    int f[31];                         
    int fid(int n)
    {
        f[0] = 0;                     
        f[1] = 1;                      
        for(int i = 2; i <= n; ++i)
        {
            f[i] = f[i-1] + f[i-2];   
        }
        return f[n];                  
    }
    return 0;
}
```

```c
int fid(int len,int *array)
{
    if (array[0] = 0)
    {
        return array[0];
    }

    else if (array[1] = 1)
    {
        return array[1];
    }
    else
    {
        for (int i = 2; i <= len; ++i)
        {
            array[i] = array[i - 1] + array[i - 2];
        }
        return array[len];
    }
}
```



```c
#define call(...) ({ *(++top) = (Frame) { .pc = 0, __VA_ARGS__ }; })
#define ret()     ({ top--; })
#define goto(loc) ({ f->pc = (loc) - 1; })

void hanoi(int n, char from, char to, char via) {
  Frame stk[64], *top = stk - 1;
  call(n, from, to, via);
  for (Frame *f; (f = top) >= stk; f->pc++) {
    switch (f->pc) {
      case 0: if (f->n == 1) { printf("%c -> %c\n", f->from, f->to); goto(4); } break;
      case 1: call(f->n - 1, f->from, f->via, f->to);   break;
      case 2: call(       1, f->from, f->to,  f->via);  break;
      case 3: call(f->n - 1, f->via,  f->to,  f->from); break;
      case 4: ret();                                    break;
      default: assert(0);
    }
  }
}


 
int main()
{
    int n;
    cnt = 0;
    scanf ("%d", &n);
    hanoi(n, 'A', 'B', 'C');
    return 0;
}

```

```c
#include <stdio.h>
#include <unistd.h>

#define REGS_FOREACH(_)  _(X) _(Y)
#define OUTS_FOREACH(_)  _(A) _(B) _(C) _(D) _(E) _(F) _(G)
#define RUN_LOGIC        X1 = !X && Y; \
                         Y1 = !X && !Y; \
                         A  = (!X && !Y) || (X && !Y); \
                         B  = 1; \
                         C  = (!X && !Y) || (!X && Y); \
                         D  = (!X && !Y) || (X && !Y); \
                         E  = (!X && !Y) || (X && !Y); \
                         F  = (!X && !Y); \
                         G  = (X && !Y); 

#define DEFINE(X)   static int X, X##1;
#define UPDATE(X)   X = X##1;
#define PRINT(X)    printf(#X " = %d; ", X);

int main() {
  REGS_FOREACH(DEFINE);

  OUTS_FOREACH(DEFINE);
  while (1) { // clock
    RUN_LOGIC;
    OUTS_FOREACH(PRINT);
    REGS_FOREACH(UPDATE);
    putchar('\n');
    fflush(stdout);
    sleep(1);
  }
}
```



#### c语言中代码执行的细节:

​	编译是对指向的源文件进行编译
​	链接是指将其他文件和源文件进行组装

​	静态变量是从程序启动到运行结束为止持续存在的变量。因此，静态变量总是在虚拟地址空间上占有固定的区域。                     
​	静态变量中有全局变量、文件内 `static` 变量和指定 `static` 的局部变量。因为这些变量的有效作用域各不相同，所以编译和连接时具有不同的意义，但是运行的时候它们都是以相似的方式被使用的    
​	`cc -c test.c`//形成.o文件
​	为了在链接器中将名称结合起来，各目标代码大多都具备一个符号表(symbol table)(详细内容需要依赖实现细节)                					       																													                               											-------《征服C指针》  

```c
nm test.out //观察内部运行地址                          
```

​                           



```c
征服C指针                                                                        
#include<stdio.h>


int array[10]={1,2,6,4,3,2,33,3,2,9};
void quick_sort_sub(int *data, int left, int right){
    int left_index=left;
    int right_index=right;
    int pivot=data[left+right/2];
    while(left_index<=right_index){
      for(;data[left_index]<pivot;left_index++);
      for(;data[right_index]>pivot;right_index++);
      if(left_index<=right_index){
            SWAP(data[right_index],data[left_index]);
            left_index++;
            right_index++;
      }
      if(right_index>left)
            quick_sort_sub(data,left,right_index);
      if(left_index<right)
            quick_sort_sub(data,left_index,right);
    }
}

void quick_sort(int *data, int data_size){
    quick_sort_sub(data, 0, data_size - 1);
}

int main(){
      quick_sort(array,10);
      return 0;
}
```



```c
截取字符串
#include<stdio.h>

int main(){
      int            hoge=0x12345678;
      unsigned char* hoge_p=(unsigned char*)&hoge;
      printf("%x\n",hoge_p[0]);
      printf("%x\n",hoge_p[1]);
      printf("%x\n",hoge_p[2]);
      printf("%x\n",hoge_p[3]);
      printf("%x\n",hoge_p[4]);
      return 0;
}
```



------



#### 文件

​    文件的读取:代码的执行都是在内存当中。内存是一个很宽泛的概念(包括处理器寄存器内存、L1~L3三级缓存、以及RAM,即掉电不保存任何文件)，我们使用文件的目的是保存不仅是程序本身，还有文件输入和输出的数据。

######     文件指针

​	缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字，文件状态及文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体类型是有系统声明的，取名FILE。

```c
指向和保存文件信息的结构体
        struct _iobuf {
                char *_ptr;
                int   _cnt;
                char *_base;
                int   _flag;
                int   _file;
                int   _charbuf;
                int   _bufsiz;
                char *_tmpfname;
               };
        typedef struct _iobuf FILE;
        FILE* pf;
```

​	FILE* pf是一个指向FILE类型数据的指针变量。可以使pf指向某个文件的文件信息区（是一个结构体变量）。通过该文件信息区中的信息就能够访问该文件。也就是说，通过文件指针变量能够找到与它关联的文件。
​        

<img src="D:\Note\MD笔记\Image\file1.png" alt="image-20230827111017889" style="zoom: 60%;" />

```c
文件读写

    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    #include<stdlib.h>  
    #include <string.h>
    int	main() 
    {
        FILE* fp = fopen("test.txt", "a+");
        if (NULL == fp) {
            printf("打开失败\n");
        }
        char buffer[] = "hello word";
        fwrite(buffer, sizeof(char), strlen(buffer), fp);
        fclose(fp);
        return 0;
    }
```

###### 文件操作指令

| 指令 |                        描述                        |
| :--: | :------------------------------------------------: |
|  rt  |           只读打开一个文本文件，只读数据           |
|  wt  |        只写或创建一个新的文本文件，只写数据        |
|  at  |      追加打开一个文本文件，并在文件末尾写数据      |
|  rb  |          只读打开一个二进制数据，只读数据          |
|  wb  |       只写或创建一个新的二进制文件，只写数据       |
|  ab  |     追加打开一个二进制文件，并在文件末尾写数据     |
| rt+  |            读写一个文本文件，允许读和写            |
| wt+  |        读写打开或建立一个文本文件，允许读写        |
| at+  |  读写打开一个文本文件，允许读，或在文件末尾写数据  |
| rb+  |           读写一个二进制文件，允许读和写           |
| wb+  |       读写打开或建立一个二进制文件，允许读写       |
| ab+  | 读写打开一个二进制文件，允许读，或在文件末尾写数据 |

（2）凡用 “r” 打开一个文件时，该文件必须已经存在，且只能从该文件读出；
（3）用 “w” 打开的文件只能向该文件写入。若打开的文件不存在，则以指定的文件名建立该文件，若打开的文件已经存在，则将该文件删去，重建一个新文件；
（4）若要向一个已存在的文件追加新的信息，只能用 “a” 方式打开文件。但此时该文件必须是存在的，否则将会出错。
（5）在打开一个文件时，如果出错，`fopen` 将返回一个空指针值NULL。在程序中可以用这一信息来判别是否完成打开文件的工作，并作相应的处理。因此常用以下程序段打开文件:
（6）把一个文本文件读入内存时，要将ASCII 码转换成二进制码，而把文件以文本方式写入磁盘时，也要把二进制码转换成ASCII 码，因此文本文件的读写要花费较多的转换时间。对二进制文件的读写不存在这种转换。
（7）标准输入文件(键盘)，标准输出文件(显示器)，标准出错输出(出错信息)是由系统打开的，可直接使用





#### 预处理器

C语言预处理器是C语言编译器的一部分，它负责在实际编译之前对源代码进行预处理。预处理器通过对源代码进行一系列文本替换和宏展开等操作，生成修改后的源代码，然后将其传递给编译器进行编译。下面是C语言预处理器的一些关键功能和指令：

|   指令   |                            描述                             |
| :------: | :---------------------------------------------------------: |
| \#define |                           定义宏                            |
| #include |                     包含一个源代码文件                      |
|  #undef  |                       取消已定义的宏                        |
| \#ifdef  |                  如果宏已经定义，则返回真                   |
| \#ifndef |                  如果宏没有定义，则返回真                   |
|   \#if   |              如果给定条件为真，则编译下面代码               |
|  \#else  |                       \#if 的替代方案                       |
|  \#elif  | 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 |
| \#endif  |               结束一个 #if……#else 条件编译块                |
| \#error  |               当遇到标准错误时，输出错误消息                |
| \#pragma |      使用标准化方法，向编译器发布特殊的命令到编译器中       |

```c
#define  message_for(a, b) \
    printf(#a " and " #b ": We love you!\n")

#define tokenpaster(n,token) \
    printf (#token #n , token##n)
/*
	“#”需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）
	“##”宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记
*/


#define MESSAGE 0

#if !defined (MESSAGE)
    #define MESSAGE "You wish!"
#endif
/*
 	预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：
*/


#define swep(x) ((x)*(x))//外层括号可有可无

/*
	在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格
*/

```



1. **宏替换**：预处理器允许你使用`#define`指令定义宏，然后在代码中使用宏名称来代替一组代码或常量。宏替换是一种文本替换，不进行类型检查。例如：
   
   ```c
   #define PI 3.14159265359
   int radius = 5;
   double circumference = 2 * PI * radius;
   ```
   
2. **条件编译**：预处理器提供条件编译指令，如`#if`、`#ifdef`、`#ifndef`、`#elif`、`#else`和`#endif`，允许根据条件选择性地包含或排除代码块。这对于创建跨平台代码或调试代码非常有用。

3. **文件包含**：使用`#include`指令，可以将其他源文件包含到当前源文件中。这对于将代码模块化并重复使用代码很有帮助。

4. **条件编译宏**：通过定义条件编译宏，可以根据编译器选项或平台选择性地编译不同部分的代码。例如：
   
   ```c
   #ifdef DEBUG
   // 调试代码
   #endif
   ```
   
5. **字符串化**：使用`#`操作符，你可以将宏参数转换为字符串常量。这对于生成调试信息或日志消息时很有用。
   ```c
   #define LOG(message) printf("Log: %s\n", #message)
   ```

6. **宏连接**：使用`##`操作符，你可以将两个宏参数连接在一起。这对于创建动态变量名或函数名很有帮助。
   
   ```c
   #define CONCAT(a, b) a##b
   int xy = 42;
   ```
   
7. **去掉注释**：预处理器会删除源代码中的注释，以减小编译后的文件大小。

8. **预定义宏**：预处理器定义了一些特定的预定义宏，例如`__FILE__`、`__LINE__`、`__DATE__`和`__TIME__`，可以在代码中使用以获取文件名、行号和编译时间等信息。

9. **头文件保护**：使用头文件保护宏，可以防止头文件的多次包含。这是通过在头文件中使用条件编译指令来实现的。

C语言预处理器在编译过程中起到重要作用，它能够在编译前修改源代码，使得代码更加灵活和可维护。然而，要谨慎使用宏，以避免潜在的代码可读性和错误调试问题。



###### define关键字的使用

`#define` 是C和C++等编程语言中的一个预处理指令，用于创建宏定义（宏），可以用来定义常量、函数、条件编译以及进行代码替换等。以下是`#define` 的使用方法：

1. **定义常量**：
   ```c
   #define PI 3.14159265359
   ```
   这会创建一个名为 `PI` 的常量，其值为 `3.14159265359`。这种常量通常用于提高代码的可读性，避免在多个地方使用硬编码的值。

2. **定义函数宏**：
   ```c
   #define SQUARE(x) ((x) * (x))
   ```
   这将创建一个函数宏 `SQUARE`，它接受一个参数 `x` 并返回 `x * x`。函数宏通常用于简化代码，减少重复。

3. **条件编译**：
   ```c
   #define DEBUG
   #ifdef DEBUG
   // 在调试模式下执行的代码
   #endif
   ```
   在这个示例中，`#define DEBUG` 用于定义一个宏，然后使用 `#ifdef` 来检查是否定义了 `DEBUG` 宏。根据条件编译，可以选择性地包含或排除特定的代码块。

4. **条件编译中的宏定义**：
   ```c
   #define MAX_SIZE 100
   #ifdef MAX_SIZE
   int arr[MAX_SIZE];
   #endif
   ```
   这里，`MAX_SIZE` 宏在条件编译中用于确定数组的最大大小。

5. **使用宏定义进行代码替换**：
   ```c
   #define MAX(a, b) ((a > b) ? a : b)
   int result = MAX(x, y);
   ```
   在这个示例中，`MAX` 宏定义用于比较两个值 `x` 和 `y` 并返回较大的值。这在简化代码和提高可读性方面非常有用。

6. **字符串连接**：
   ```c
   #define FULL_NAME(first, last) (first " " last)
   char name[] = FULL_NAME("John", "Doe");
   ```
   `FULL_NAME` 宏定义用于将两个字符串连接成一个完整的名字。

7. **条件宏定义**：
   ```c
   #define MAX_SIZE 100
   #ifndef MAX_SIZE
   #define MAX_SIZE 50
   #endif
   ```
   这个示例中，`MAX_SIZE` 宏在没有定义的情况下被设置为默认值。

需要注意的是，宏定义会进行简单的文本替换，因此在使用时要小心，确保不会引发不必要的副作用或错误。此外，`#define` 中的括号是为了确保在宏展开时表达式的优先级正确，特别是在复杂的宏中。维护和调试宏定义时需要小心，以避免潜在的问题。







#### 预定义宏

|    宏    |                        描述                         |
| :------: | :-------------------------------------------------: |
| __DATE__ | 当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。 |
| __TIME__ |  当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。   |
| __FILE__ |        这会包含当前文件名，一个字符串常量。         |
| __LINE__ |         这会包含当前行号，一个十进制常量。          |
| __STDC__ |      当编译器以 ANSI 标准编译时，则定义为 1。       |



------



#### 错误输出

在C语言中，你可以使用标准错误流（`stderr`）来输出错误消息和诊断信息，这些错误消息通常用于指示程序在运行时遇到了问题。C语言提供了一些用于向标准错误流输出信息的函数和宏。以下是在C语言中进行错误输出的一些常见方法：



|  错误函数  |                             描述                             |
| :--------: | :----------------------------------------------------------: |
| strerror() | **strerror()** 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。 |
|   errno    |                     printf(”%m”, errno);                     |
|  perror()  | **perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式 |



###### 使用`fprintf`函数：

`fprintf`函数可以将输出发送到指定的流，包括标准错误流`stderr`。你可以使用它来输出错误消息。

```c
#include <stdio.h>

int main() {
    fprintf(stderr, "这是一个错误消息。\n");
    return 1;  // 返回非零值表示程序出错
}
```

在上面的示例中，`fprintf`函数将错误消息发送到`stderr`流，并返回非零值以表示程序出错。

###### **使用`perror`函数**：

`perror`函数用于将一个描述性错误消息与当前错误代码一起输出到标准错误流。通常，它用于显示与系统调用相关的错误消息。

```c
#include <stdio.h>
#include <errno.h>

int main() {
    FILE *file = fopen("non_existent_file.txt", "r");
    if (file == NULL) {
        perror("打开文件时发生错误");
        return 1;
    }
    return 0;
}
```

在上面的示例中，如果文件打开失败，`perror`函数将显示一个描述性错误消息，并指示错误类型。

###### **使用`assert`宏**：

`assert`宏用于在程序中添加断言，以检查条件是否为真。如果断言条件为假，`assert`会将错误消息发送到标准错误流并终止程序。

```c
#include <stdio.h>
#include <assert.h>

int main() {
    int x = 10;
    assert(x == 20);  // 断言条件为假，程序终止，错误消息发送到stderr
    return 0;
}
```

注意：在发布版本中，`assert`通常被禁用，因此它在生产环境中不会触发。

###### **使用`exit`函数**：

你可以使用`exit`函数来立即终止程序的执行，并指定一个退出码。通常，非零的退出码用于指示程序出错。

```c
#include <stdio.h>

int main() {
    // 程序逻辑...
    if (/*某个条件不满足*/) {
        fprintf(stderr, "发生错误。\n");
        return 1;  // 返回非零值表示程序出错
    }
    return 0;
}
```

在上面的示例中，如果某个条件不满足，程序将输出错误消息并返回非零值以指示错误。

无论你使用哪种方法，都可以在C语言程序中进行错误输出，以便诊断和处理运行时错误。通常，标准错误流`stderr`用于输出错误消息，而标准输出流`stdout`用于正常输出。







#### C可变参数

在C语言中，你可以使用可变参数函数（Variadic Functions）来编写能够接受不定数量参数的函数。C语言的标准库中包含了一些使用可变参数的函数，例如`printf`和`scanf`。要创建自己的可变参数函数，你需要使用标准库头文件`stdarg.h`中的一些宏和函数。以下是关于C可变参数的详细介绍：

###### 使用`stdarg.h`头文件：

要使用可变参数函数，首先需要包含`stdarg.h`头文件，该头文件包含了处理可变参数的宏和函数。

```c
#include <stdarg.h>
```

###### 创建可变参数函数：

要创建一个可变参数函数，你需要按照以下步骤进行：

1. 定义一个带有固定参数的函数，然后在参数列表的末尾添加省略号（`...`），表示接受可变参数。

   ```c
   int sum(int count, ...) {
       // 可变参数函数体
   }
   ```

2. 在函数内部，你可以使用宏`va_list`、`va_start`和`va_arg`来访问可变参数列表。

   - `va_list`：声明一个可变参数列表。
   - `va_start`：初始化可变参数列表，使其指向第一个可变参数。
   - `va_arg`：从可变参数列表中获取下一个参数的值，根据参数的类型和位置。

3. 在函数结束时，使用`va_end`来清理可变参数列表。

   ```c
   va_end(arg_list);
   ```

###### 示例：计算可变参数的和

以下是一个简单的例子，演示如何创建一个可变参数函数来计算传递给它的整数参数的和：

```c
#include <stdio.h>
#include <stdarg.h>

int sum(int count, ...) {
    va_list arg_list;
    va_start(arg_list, count);

    int result = 0;
    for (int i = 0; i < count; i++) {
        int num = va_arg(arg_list, int);
        result += num;
    }

    va_end(arg_list);
    return result;
}

int main() {
    int total = sum(5, 1, 2, 3, 4, 5);
    printf("总和：%d\n", total);
    return 0;
}
```

在这个示例中，`sum`函数接受一个整数参数`count`，表示后续将传递的整数参数数量不定。它使用`va_list`、`va_start`和`va_arg`来访问可变参数列表，并计算它们的总和。

使用可变参数函数时，请确保提供足够的信息来正确处理参数。可变参数函数通常不提供参数类型检查，因此在使用时要小心，确保传递的参数数量和类型与函数的期望相匹配。





#### C内存管理

C语言的内存管理是程序员手动分配和释放内存的过程，它是一项重要的任务，用于确保程序正确、高效地使用计算机内存资源。C语言提供了一些标准库函数来进行内存分配和释放，主要包括`malloc`、`calloc`、`realloc`和`free`等函数。以下是关于C语言内存管理的详细介绍：

|                     函数原型                     | 描述                                                         |
| :----------------------------------------------: | :----------------------------------------------------------- |
|      **void \*calloc(int num, int size);**       | 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0。 |
|          **void free(void \*address);**          | 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。 |
|           **void \*malloc(int num);**            | 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。 |
| **void \*realloc(void \*address, int newsize);** | 该函数重新分配内存，把内存扩展到 **newsize**。               |



###### 内存分配函数：

1. **`malloc`（Memory Allocation）**：`malloc`函数用于动态分配指定大小的内存块，并返回一个指向首地址的指针。分配的内存不会被初始化，可能包含随机数据。

   ```c
   void *malloc(size_t size);
   ```

   示例：
   ```c
   int *arr = (int *)malloc(sizeof(int) * 10);
   ```

2. **`calloc`（Contiguous Allocation）**：`calloc`函数用于动态分配指定数量和大小的连续内存块，并返回一个指向首地址的指针。分配的内存会被初始化为零。

   ```c
   void *calloc(size_t num_elements, size_t element_size);
   ```

   示例：
   ```c
   int *arr = (int *)calloc(10, sizeof(int));
   ```

###### 内存释放函数：

1. **`free`**：`free`函数用于释放通过`malloc`、`calloc`或`realloc`分配的内存块，以便将其返回给系统以供重新分配。

   ```c
   void free(void *ptr);
   ```

   示例：
   ```c
   free(arr);
   ```

###### 内存重新分配函数：

1. **`realloc`（Reallocate）**：`realloc`函数用于更改先前分配的内存块的大小。它接受一个指向已分配内存的指针，以及新的大小，并返回一个指向重新分配内存的指针。如果无法在原地重新分配，则会分配新的内存块，并将数据从旧内存复制到新内存。

   ```c
   void *realloc(void *ptr, size_t new_size);
   ```

   示例：
   ```c
   int *new_arr = (int *)realloc(arr, sizeof(int) * 20);
   ```

###### 内存管理的注意事项：

1. **内存泄漏**：不释放已分配的内存会导致内存泄漏。每次使用`malloc`、`calloc`或`realloc`分配内存后，都应该使用`free`来释放内存。

2. **野指针**：访问已释放的内存或未初始化的指针会导致未定义的行为。确保在释放内存后将指针置为`NULL`，以避免野指针。

3. **越界访问**：不要访问数组或内存块的越界部分，这可能会破坏数据或导致程序崩溃。

4. **内存分配失败**：内存分配函数可能因为内存不足而失败，因此应该检查它们的返回值，确保分配成功。

5. **合理使用动态内存**：动态内存分配应该谨慎使用，避免不必要的内存分配和释放操作，以提高程序性能和稳定性。

C语言的内存管理是程序员的责任，需要小心谨慎地处理，以避免内存泄漏、野指针和其他内存相关的问题。最好的实践是在分配内存后及时释放它，并确保正确处理所有边界情况。如果不小心处理内存，可能会导致严重的程序错误。



#### System()函数详解

|   指令   |                             描述                             |
| :------: | :----------------------------------------------------------: |
| color 0A | 其中color后面的0是背景色代号，A是前景色代号。各颜色代码如下： 0=黑色 1=蓝色 2=绿色 3=湖蓝色 4=红色 5=紫色 6=黄色 7=白色 8=灰色 9=淡蓝色 A=淡绿色 B=淡浅绿色 C=淡红色 D=淡紫色 E=淡黄色 F=亮白色 |
|  ASSOC   |                   显示或修改文件扩展名关联                   |
|    AT    |                计划在计算机上运行的命令和程序                |
|  ATTRIB  |                      显示或更改文件属性                      |
|  BREAK   |                 设置或清除扩展式 CTRL+C 检查                 |
|  CACLS   |              显示或修改文件的访问控制列表(ACLs)              |
|   CALL   |                 从另一个批处理程序调用这一个                 |
|    CD    |                 显示当前目录的名称或将其更改                 |
|   CHCP   |                    显示或设置活动代码页数                    |
|  CHDIR   |                 显示当前目录的名称或将其更改                 |
|  CHKDSK  |                    检查磁盘并显示状态报告                    |
| CHKNTFS  |                  显示或修改启动时间磁盘检查                  |
|   CLS    |                           清除屏幕                           |
|   CMD    |             打开另一个 Windows 命令解释程序窗口              |
|  COLOR   |                 设置默认控制台前景和背景颜色                 |
|   COMP   |                   比较两个或两套文件的内容                   |
| COMPACT  |               显示或更改 NTFS 分区上文件的压缩               |
| CONVERT  |          将 FAT 卷转换成 NTFS。您不能转换当前驱动器          |
|   COPY   |                将至少一个文件复制到另一个位置                |
|   DATE   |                        显示或设置日期                        |
|   DEL    |                       删除至少一个文件                       |
|   DIR    |                 显示一个目录中的文件和子目录                 |
| DISKCOMP |                      比较两个软盘的内容                      |
| DISKCOPY |               将一个软盘的内容复制到另一个软盘               |
|  DOSKEY  |            编辑命令行、调用 Windows 命令并创建宏             |
|   ECHO   |               显示消息，或将命令回显打开或关上               |
| ENDLOCAL |                 结束批文件中环境更改的本地化                 |
|  ERASE   |                       删除至少一个文件                       |
|   EXIT   |               退出 CMD.EXE 程序(命令解释程序)                |
|    FC    |               比较两个或两套文件，并显示不同处               |
|   FIND   |                    在文件中搜索文字字符串                    |
| FINDSTR  |                      在文件中搜索字符串                      |
|   FOR    |           为一套文件中的每个文件运行一个指定的命令           |
|  FORMAT  |               格式化磁盘，以便跟 Windows 使用                |
|  FTYPE   |            显示或修改用于文件扩展名关联的文件类型            |
|   GOTO   |     将 Windows 命令解释程序指向批处理程序中某个标明的行      |
| GRAFTABL |           启用 Windows 来以图像模式显示扩展字符集            |
|   HELP   |                 提供 Windows 命令的帮助信息                  |
|    IF    |                 执行批处理程序中的条件性处理                 |
|  LABEL   |                  创建、更改或删除磁盘的卷标                  |
|    MD    |                           创建目录                           |
|  MKDIR   |                           创建目录                           |
|   MODE   |                        配置系统设备。                        |
|   MORE   |                    一次显示一个结果屏幕。                    |
|   MOVE   |               将文件从一个目录移到另一个目录。               |
|   PATH   |               显示或设置可执行文件的搜索路径。               |
|  PAUSE   |                 暂停批文件的处理并显示消息。                 |
|   POPD   |            还原 PUSHD 保存的当前目录的上一个值。             |
|  PRINT   |                        打印文本文件。                        |
|  PROMPT  |                  更改 Windows 命令提示符。                   |
|  PUSHD   |                保存当前目录，然后对其进行更改                |
|    RD    |                          删除目录。                          |
| RECOVER  |                 从有问题的磁盘恢复可读信息。                 |
|   REM    |              记录批文件或 CONFIG.SYS 中的注释。              |
|   REN    |                         重命名文件。                         |
|  RENAME  |                         重命名文件。                         |
| REPLACE  |                          替换文件。                          |
|  RMDIR   |                          删除目录。                          |
|   SET    |             显示、设置或删除 Windows 环境变量。              |
| SETLOCAL |                开始批文件中环境更改的本地化。                |
|  SHIFT   |                更换批文件中可替换参数的位置。                |
|   SORT   |                       对输入进行分类。                       |
|  START   |            启动另一个窗口来运行指定的程序或命令。            |
|  SUBST   |                  将路径跟一个驱动器号关联。                  |
|   TIME   |                     显示或设置系统时间。                     |
|  TITLE   |                设置 CMD.EXE 会话的窗口标题。                 |
|   TREE   |            以图形模式显示驱动器或路径的目录结构。            |
|   TYPE   |                     显示文本文件的内容。                     |
|   VER    |                     显示 Windows 版本。                      |
|  VERIFY  |         告诉 Windows 是否验证文件是否已正确写入磁盘          |
|   VOL    |       显示磁盘卷标和序列号。XCOPY  复制文件和目录树。        |





#### C枚举

C语言中的枚举（Enumeration）是一种用户定义的数据类型，用于创建一组具有离散值的常量。枚举允许程序员为常用的值分配易于记忆的名称，以提高代码的可读性和可维护性。以下是关于C语言枚举的详细解释：

###### **定义一个枚举类型**：

在C语言中，你可以使用`enum`关键字来定义一个枚举类型。定义枚举类型的一般语法如下：

```c
enum EnumName {
    Value1,
    Value2,
    // ...
    ValueN
};
```

- `EnumName` 是枚举类型的名称，可以自定义。
- `Value1`、`Value2`、...、`ValueN` 是枚举常量的名称。它们被称为枚举成员，它们的值默认从0开始递增。

###### **使用枚举类型**：

一旦定义了枚举类型，你可以创建该类型的变量，并将其赋值为枚举成员之一。

```c
enum EnumName day = Value2;
```

这里，我们创建了一个名为`day`的变量，并将其赋值为`EnumName`枚举类型中的一个成员，如`Value2`。

###### **枚举成员的整数值**：

枚举成员默认从0开始递增，但你也可以显式地为它们分配整数值。例如：

```c
enum Color {
    RED = 1,
    GREEN = 2,
    BLUE = 4,
    YELLOW = 5
};
```

在这个示例中，枚举成员`RED`的值为1，`GREEN`的值为2，以此类推。

###### **访问枚举成员的值**：

你可以使用枚举成员的名称来访问它们的值。例如：

```c
enum Color myColor = GREEN;
printf("The color is %d\n", myColor);
```

这将输出 "The color is 2"，因为`myColor`被赋值为`GREEN`，而`GREEN`的值为2。

###### **枚举的用途**：

枚举常常用于以下情况：

1. 表示一组相关的选项或状态，如颜色、星期几、月份等。
2. 增强代码的可读性和可维护性，因为枚举成员通常具有描述性的名称。
3. 在条件语句、开关语句等中用作标志。

例如，你可以使用枚举来表示一周的天：

```c
enum Day {
    SUNDAY,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY
};
```

这样，你可以更容易地理解和操作与日期相关的代码。

总之，C语言中的枚举是一种强大的工具，用于创建一组有序的常量，提高代码的可读性和可维护性。通过为枚举成员分配整数值，你还可以灵活地控制这些常量的值。





#### C函数指针和回调函数

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
typedef int (*Fun1)(int);//声明也可写成int (*Fun1)(int x)，但习惯上一般不这样。
typedef int (*Fun2)(int, int);//参数为两个整型，返回值为整型
typedef void (*Fun3)(void);//无参数和返回值
typedef void* (*Fun4)(void*);//参数和返回值都为void*指针


int max(int x, int y)
{
    return x > y ? x : y;
}

int main(void)
{
    int (*p)(int, int) = &max; // &可以省略，函数指针可以在函数中定义
    int a, b, c, d;

    printf("请输入三个数字:");
    scanf("%d %d %d", &a, &b, &c);

    d = p(p(a, b), c);

    printf("最大的数字是: %d\n", d);

    return 0;
}
```





###### 指向函数的指针

```c
#include<stdio.h>

int function(int i){
      return i*i;
}
int (*func_p)(int);

int main(void){
      func_p=function;
      printf("%d",func_p(10));
      return 0;   
}

//指向函数的指针的数组
#include<stdio.h>

void func1(int i){
      printf("1");
}

void func2(int i){
      printf("2");
}

void func3(int i){
      printf("3");
}

void func4(int i){
      printf("4");
}

void (*func_table[])(int)={
      func1,
      func2,
      func3,
      func4
};

int main(void){
      func_table[1](1);
      return 0;   
}
```



------



###### 函数指针作为函数的参数

```c
#include <stdio.h>
#include <stdlib.h>

typedef void(*FunType)(int);
//前加一个typedef关键字，这样就定义一个名为FunType函数指针类型，而不是一个FunType变量。
//形式同 typedef int* PINT;
void myFun(int x);
void hisFun(int x);
void herFun(int x);
void callFun(FunType fp,int x);
int main()
{
    callFun(myFun,100);//传入函数指针常量，作为回调函数
    callFun(hisFun,200);
    callFun(herFun,300);

    return 0;
}

void callFun(FunType fp,int x)
{
    fp(x);//通过fp的指针执行传递进来的函数，注意fp所指的函数有一个参数
}

void myFun(int x)
{
    printf("myFun: %d\n",x);
}
void hisFun(int x)
{
    printf("hisFun: %d\n",x);
}
void herFun(int x)
{
    printf("herFun: %d\n",x);
}

```

###### 函数指针作为函数返回类型

```c
void (* func5(int, int, float ))(int, int)
{
    ...
}
```

###### 函数指针数组

```c
/* 方法1 */
void (*func_array_1[5])(int, int, float);

/* 方法2 */
typedef void (*p_func_array)(int, int, float);
p_func_array func_array_2[5];

```

###### 回调函数的定义：

回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。

![](D:\Note\MD笔记\Image\Function.png)



把一段可执行的代码像参数传递那样传给其他代码，而这段代码会在某个时刻被调用执行，这就叫做回调。

如果代码立即被执行就称为同步回调，如果过后再执行，则称之为异步回调。

回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。

回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应

```c
#include <stdio.h>

int Callback_1(int a)   ///< 回调函数1
{
    printf("Hello, this is Callback_1: a = %d ", a);
    return 0;
}

int Callback_2(int b)  ///< 回调函数2
{
    printf("Hello, this is Callback_2: b = %d ", b);
    return 0;
}

int Callback_3(int c)   ///< 回调函数3
{
    printf("Hello, this is Callback_3: c = %d ", c);
    return 0;
}

int Handle(int x, int (*Callback)(int)) ///< 注意这里用到的函数指针定义
{
    Callback(x);
}

int main()
{
    Handle(4, Callback_1);
    Handle(5, Callback_2);
    Handle(6, Callback_3);
    return 0;
}

```



------



#### 位域

C语言中的位域（Bit-fields）是一种数据结构，用于将数据字段划分为位段，以便有效地使用内存空间。位域允许你指定一个字段的宽度（以位为单位），从而节省内存。通常，位域用于存储和操作具有特定位数的标志或状态信息。以下是关于C语言位域的详细介绍：

###### 位域的定义：

在C语言中，你可以使用`struct`结构体来定义位域。在结构体中，你可以使用冒号（`:`）运算符来指定字段的位宽度。例如：

```c
struct Flags {
    unsigned int isOn : 1;     // 占1位
    unsigned int isWorking : 1; // 占1位
    unsigned int color : 3;    // 占3位
};
```

在这个示例中，我们定义了一个`struct`结构体，包含了三个位域成员。

###### 位域的操作：

使用位域后，你可以像操作普通整数一样操作位域成员。例如，设置位域的值，读取位域的值，或者进行位运算。以下是一些位域操作的示例：

```c
struct Flags status;

status.isOn = 1;         // 设置isOn位域为1
status.isWorking = 0;    // 设置isWorking位域为0
status.color = 2;        // 设置color位域为2

int working = status.isWorking; // 读取isWorking位域的值
int color = status.color;       // 读取color位域的值
```

###### 注意事项：

1. **位宽度小于数据类型大小**：位域的宽度不能大于其数据类型的大小。例如，一个`char`类型的位域不能有10位。

2. **位域的顺序**：位域的存储顺序（高位到低位或低位到高位）取决于编译器和平台，可能会有不同的实现。

3. **跨字节边界**：位域的定义可能会跨越字节边界，这取决于编译器的实现。这可能会导致存储和访问效率问题。

4. **不具有地址**：位域没有自己的地址，因此无法对位域进行取址操作（即不能使用`&`运算符）。

5. **位域的移植性**：由于位域的实现因编译器和平台而异，因此在不同系统上的行为可能会有所不同。在编写具有跨平台需求的代码时，要小心使用位域。

位域在某些情况下非常有用，例如在嵌入式系统中，需要紧凑地表示硬件寄存器的位。然而，由于其实现的不确定性，位域在通用应用中使用较少。如果需要确保特定的位操作行为，通常更安全的方法是使用位掩码和位运算符。



------



#### 共用体

C语言中的共用体（Union）是一种特殊的数据结构，允许在相同的内存位置存储不同的数据类型。共用体的成员共享相同的内存空间，但只能存储其中一个成员的值。这使得共用体非常适合用于需要节省内存或处理多种数据类型的情况。以下是有关C语言共用体的详细介绍：

###### 共用体的定义：

共用体的定义类似于结构体，但使用关键字`union`。例如：

```c
union Data {
    int i;
    float f;
    char str[20];
};
```

在这个示例中，我们定义了一个名为`Data`的共用体，它包含了三个不同的成员：一个整数`i`、一个浮点数`f`和一个字符数组`str`。

###### 共用体的大小：

共用体的大小等于其成员中最大的成员的大小。在上面的示例中，如果`int`占用4个字节，`float`占用4个字节，而字符数组`str`占用20个字节，那么整个共用体的大小将是20个字节。

###### 共用体的使用：

可以使用共用体成员的方式与访问结构体的成员相同。然而，由于共用体的成员共享内存，只能存储其中一个成员的值。例如：

```c
union Data data;

data.i = 10;     // 存储整数值
data.f = 3.14;   // 存储浮点数值
strcpy(data.str, "Hello"); // 存储字符串

printf("整数值：%d\n", data.i);   // 输出整数值
printf("浮点数值：%f\n", data.f); // 输出浮点数值
printf("字符串：%s\n", data.str); // 输出字符串
```

这里的关键点是，在每次赋值给共用体时，之前存储的值将被覆盖。

###### 共用体的应用：

共用体通常用于以下情况：

1. **节省内存**：当你需要多种数据类型共享相同的内存位置时，可以使用共用体来节省内存。这对于嵌入式系统和低内存环境非常有用。

2. **处理不同数据类型**：有时需要处理不同数据类型的数据，例如在解析二进制数据时。共用体可以用于处理这种情况，每次只使用其中一个成员。

3. **实现联合体**：共用体可用于创建联合体数据结构，其中多个数据成员共享相同的内存位置。

尽管共用体在某些情况下非常有用，但也需要小心使用，因为共用体的成员共享内存，可能导致数据不一致或错误。在使用共用体时，必须确保正确地跟踪哪个成员包含有效的数据。



------



#### C结构体

###### 结构体的定义

```c
struct tag { 
    member-list
    member-list 
    member-list  
    ...
} variable-list ;
 
-> 运算符：用于指针访问结构体成员，语法为 pointer->member，等价于 (*pointer).member。
&是运营商的地址，可以简单地读作“地址”
*是取消引用运算符，可以读作“指向的值”
```

###### 结构体作为参数

```c

struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};

/* 函数声明 */
void printBook( struct Books *book );
```

###### 指向结构体的指针

在C语言中，你可以使用指针来引用和操作结构体（struct）类型的数据。指向结构体的指针允许你直接访问结构体的成员，而不必复制整个结构体的内容。以下是如何声明、创建和使用指向结构体的指针的基本方法：

**1. 定义结构体类型**：

首先，你需要定义一个结构体类型。例如，下面定义了一个名为`Person`的结构体，包含姓名和年龄：

```c
struct Person {
    char name[50];
    int age;
};
```

**2. 声明指向结构体的指针**：

要声明指向结构体的指针，你需要使用结构体的类型名称，然后在变量名前加上星号`*`，如下所示：

```c
struct Person *personPtr;
```

这将声明一个名为`personPtr`的指针，它可以指向`Person`类型的结构体。

**3. 分配内存并初始化指针**：

在使用指针之前，通常需要分配内存来存储结构体的实际数据。可以使用动态内存分配函数`malloc`来分配内存，并使用指针来引用它：

```c
personPtr = (struct Person *)malloc(sizeof(struct Person));
```

这将分配足够的内存以存储一个`Person`结构体，并将指针`personPtr`指向该内存。

**4. 访问结构体成员**：

一旦指针指向了结构体，你可以使用箭头运算符`->`来访问结构体的成员，如下所示：

```c
strcpy(personPtr->name, "John");
personPtr->age = 30;
```

这将在结构体内存中设置`name`和`age`成员的值。

**5. 释放内存**：

在不再需要结构体时，你应该释放之前分配的内存，以防止内存泄漏：

```c
free(personPtr);
```

这将释放由`malloc`分配的内存。

下面是一个完整的示例，演示了如何声明、创建和使用指向结构体的指针：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Person {
    char name[50];
    int age;
};

int main() {
    struct Person *personPtr;

    // 分配内存
    personPtr = (struct Person *)malloc(sizeof(struct Person));

    // 设置结构体成员的值
    strcpy(personPtr->name, "John");
    personPtr->age = 30;

    // 访问并打印结构体成员的值
    printf("Name: %s\n", personPtr->name);
    printf("Age: %d\n", personPtr->age);

    // 释放内存
    free(personPtr);

    return 0;
}
```

这个示例演示了如何创建、访问和释放指向结构体的指针。指向结构体的指针非常有用，因为它允许你在不复制结构体的情况下操作结构体数据。

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
 

typedef struct List {
    int age;
    char name[50];
    char phone[12];
}Node;


int main() {
    Node data1;
    Node* pointer = &data1;
    data1.age = 19;
    *pointer->name = 'yang';
    *pointer->phone = "12332";

    printf("%d",pointer->age);
    printf("%s", pointer->name);
    return 0;
}
```



```c
#include <stdio.h>
struct stu//结构体可以创建新的类型
        {
    char name[100];
    char age;
    double score;
        };
int main()
{
    struct stu a={"张三",20,100};//结构体的创建和初始化
    struct stu * ac=&a;
    printf("1:%s,%d,%3.0f\n",a.name,a.age,a.score);//只知道
    printf("2:%s,%d,%3.0f\n",(*ac).age,(*ac).name,(*ac).score);
    printf("3:%s,%d,%3.0f",ac->score,ac->name,ac->age);
    return 0;
}
```

###### . 与->在c语言中的区别

在C语言中，`.`（点运算符）和`->`（箭头运算符）用于访问结构体（或联合体）类型的成员。它们之间的主要区别是用于访问成员的方式和左操作数的类型。

1. **`.`（点运算符）**：

   - `.` 用于访问结构体或联合体类型的成员。
   - 左操作数必须是一个结构体或联合体的实例，而不是指针。
   - 使用 `.` 时，你直接操作结构体或联合体的实例，而不需要间接引用。

   示例：
   ```c
   struct Point {
       int x;
       int y;
   };

   struct Point p1;
   p1.x = 10;
   p1.y = 20;
   ```

2. **`->`（箭头运算符）**：

   - `->` 用于访问结构体或联合体类型的成员，但左操作数是一个指向结构体或联合体的指针。
   - 当你有一个指向结构体的指针时，你可以使用箭头运算符来访问结构体的成员。
   - 箭头运算符允许你通过指针间接引用结构体或联合体的成员。

   示例：
   ```c
   struct Point {
       int x;
       int y;
   };
   
   struct Point *ptr = malloc(sizeof(struct Point));
   ptr->x = 10;
   ptr->y = 20;
   ```

总结：
- 使用`.`运算符直接访问结构体或联合体的成员，左操作数必须是一个结构体或联合体的实例。
- 使用`->`运算符通过指针访问结构体或联合体的成员，左操作数是指向结构体或联合体的指针。

这些运算符允许你方便地访问和操作结构体类型的数据，无论是直接还是通过指针。







###### 左值和右值的区别

在C语言中，左值（Lvalue）和右值（Rvalue）是两个重要的概念，它们用于描述表达式中的值和对象。理解左值和右值的区别对于C语言中的变量、赋值和表达式的行为非常重要。以下是关于左值和右值的详细介绍：

1. **左值（Lvalue）**：
   - 左值是一个标识符或表达式，它表示一个具体的内存位置，可以被赋值。
   - 左值通常是变量的名称，也可以是数组元素或结构体成员等。
   - 通常，左值是可以出现在赋值操作符（=）的左侧的部分。例如，`x` 是一个左值，可以执行 `x = 10;` 这样的赋值操作。
   - 左值可以出现在等号的左侧或右侧，但右侧的情况通常用于读取变量的值。

2. **右值（Rvalue）**：
   - 右值是一个表达式，它表示一个具体的值，但通常不能被赋值。
   - 右值可以是常量、字面值、函数返回值等。
   - 右值通常出现在赋值操作符（=）的右侧，用于提供要赋给左值的值。例如，`x = 10;` 中的 `10` 是一个右值。
   - 右值可以被用来计算和生成新的右值。例如，`x = 5 + 3;` 中的 `5 + 3` 是一个右值表达式，它计算出一个右值 `8` 并将其赋给左值 `x`。

3. **区别和用途**：
   - 左值表示一个可修改的内存位置，因此可以用于赋值操作。
   - 右值表示一个值，通常不能被直接修改，只能用于计算和生成新的右值。
   - 在C语言中，函数的返回值通常是右值，而变量的名称通常是左值。
   - 左值和右值的概念对于理解C语言中的运算符行为非常重要。例如，递增运算符 `++` 可以用于左值，但不能用于右值。

示例：
```c
int x = 10; // x 是左值，10 是右值
x = x + 5;  // x 是左值，x + 5 是右值
int y = x;  // x 是左值，y 是左值，x 的值作为右值
```

总之，左值表示一个可修改的内存位置，而右值表示一个值。了解左值和右值的区别有助于理解C语言中的变量和表达式的行为，以及如何正确使用它们。左值通常可以出现在赋值操作符的左侧，而右值通常出现在赋值操作符的右侧。
